The system behavior is defined in terms of explicit states and transitions.

The monitored events are:

1) Event name: getinput
   Kind: creation
   Timing: after
   Parameters: Socket sock
   Returning: InputStream input
   Pointcut: call(InputStream Socket+.getInputStream()) && target(sock)

2) Event name: enter
   Kind: event
   Timing: before
   Parameters: InputStream input
   Pointcut: call(* InputStream+.read(..)) && target(input)

3) Event name: leave
   Kind: event
   Timing: after
   Parameters: InputStream input
   Pointcut: call(* InputStream+.read(..)) && target(input)

4) Event name: set
   Kind: event
   Timing: before
   Parameters: Socket sock, int timeout
   Pointcut: call(* Socket+.setSoTimeout(int)) && target(sock) && args(timeout) && condition(timeout != 0)

The finite state behavior is defined as follows:

		start [
			getinput -> unblocked
		]
		unblocked [
			getinput -> unblocked
			set -> unblocked
			enter -> blocked
		]
		blocked [
			getinput -> blocked
			leave -> unblocked
		]

Any execution that deviates from the state transition behavior described above constitutes a violation.

The violation message that must be used in the JSON output is:

"Socket.setSoTimeout() should be set prior to entering the blocking operation."
