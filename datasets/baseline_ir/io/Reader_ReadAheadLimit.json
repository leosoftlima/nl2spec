{
  "id": "Reader_ReadAheadLimit",
  "formalism": "ere",
  "domain": "io",
  "signature": {
    "name": "Reader_ReadAheadLimit",
    "parameters": [
      {
        "type": "Reader",
        "name": "r"
      }
    ]
  },
  "ir": {
    "type": "ere",
    "events": [
      {
        "kind": "event",
        "name": "mark",
        "timing": "before",
        "parameters": [
          {
            "type": "Reader",
            "name": "r"
          },
          {
            "type": "int",
            "name": "l"
          }
        ],
        "pointcut": {
          "raw": "call(* Reader+.mark(int)) && target(r) && args(l) && if ( r instanceof BufferedReader || r instanceof LineNumberReader )",
          "calls": [
            "* Reader+.mark(int)"
          ]
        },
        "body": {
          "raw_lines": [
            "this.limit = l;",
            "this.rest = l;"
          ]
        }
      },
      {
        "kind": "event",
        "name": "read1",
        "timing": "after",
        "parameters": [
          {
            "type": "Reader",
            "name": "r"
          }
        ],
        "pointcut": {
          "raw": "call(* Reader+.read()) && target(r) && if ( r instanceof BufferedReader || r instanceof LineNumberReader )",
          "calls": [
            "* Reader+.read()"
          ]
        },
        "returning": {
          "type": "int",
          "name": "n"
        },
        "body": {
          "raw_lines": [
            "if (n != -1) {",
            "this.rest -= 1;",
            "if (this.rest < 0)",
            "this.LOC = __LOC;"
          ]
        }
      },
      {
        "kind": "event",
        "name": "readn",
        "timing": "after",
        "parameters": [
          {
            "type": "Reader",
            "name": "r"
          }
        ],
        "pointcut": {
          "raw": "call(* Reader+.read(char[], ..)) && target(r) && if ( r instanceof BufferedReader || r instanceof LineNumberReader )",
          "calls": [
            "* Reader+.read(char[], ..)"
          ]
        },
        "returning": {
          "type": "int",
          "name": "n"
        },
        "body": {
          "raw_lines": [
            "if (n != -1) {",
            "this.rest -= n;",
            "if (this.rest < 0)",
            "this.LOC = __LOC;"
          ]
        }
      },
      {
        "kind": "event",
        "name": "badreset",
        "timing": "before",
        "parameters": [
          {
            "type": "Reader",
            "name": "r"
          }
        ],
        "pointcut": {
          "raw": "call(* Reader+.reset(..)) && target(r) && condition(rest < 0) && if ( r instanceof BufferedReader || r instanceof LineNumberReader )",
          "calls": [
            "* Reader+.reset(..)"
          ]
        },
        "body": {
          "raw_lines": [
            "this.limit = 0;",
            "this.rest = 0;"
          ]
        }
      },
      {
        "kind": "event",
        "name": "goodreset",
        "timing": "before",
        "parameters": [
          {
            "type": "Reader",
            "name": "r"
          }
        ],
        "pointcut": {
          "raw": "call(* Reader+.reset(..)) && target(r) && condition(rest >= 0) && if ( r instanceof BufferedReader || r instanceof LineNumberReader )",
          "calls": [
            "* Reader+.reset(..)"
          ]
        },
        "body": {
          "raw_lines": [
            "this.rest = this.limit;"
          ]
        }
      }
    ],
    "formula": {
      "raw": "(mark | read1 | readn | goodreset)* badreset+",
      "raw_lines": [
        "(mark | read1 | readn | goodreset)* badreset+"
      ]
    },
    "violation": {
      "tag": "match",
      "raw_block": [
        "RVMLogging.out.println(Level.CRITICAL, __DEFAULT_MESSAGE);",
        "RVMLogging.out.println(Level.CRITICAL, \"The position mark has been invalidated.\");",
        "if (this.LOC != null) {",
        "RVMLogging.out.println(Level.CRITICAL, \"read() at line \" + this.LOC + \" invalidated the mark.\");"
      ]
    }
  }
}